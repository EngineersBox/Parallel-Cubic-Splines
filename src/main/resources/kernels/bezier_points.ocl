typedef struct __attribute__((packed)) Point {
    double x;
    double y;
} Point;

const Point calculateBezierPoint(const Point* a, const Point* b, const Point* c, const Point* projectionReferencePoint, double smoothFactor, int direction) {
    double pointDiffACX = c->x - a->x;
    double pointDiffACY = c->y - a->y;
    double vecACLength = sqrt(pointDiffACX * pointDiffACX + pointDiffACY * pointDiffACY);
    pointDiffACX = (pointDiffACX / vecACLength) * direction;
    pointDiffACY = (pointDiffACY / vecACLength) * direction;

    double vecProjectionFactor = fabs((b->x - projectionReferencePoint->x) * pointDiffACX + (b->y - projectionReferencePoint->y) * pointDiffACY);
    double projectedX = vecProjectionFactor * pointDiffACX;
    double projectedY = vecProjectionFactor * pointDiffACY;

    return (const Point) {
        .x = b->x - smoothFactor * projectedX,
        .y = b->y - smoothFactor * projectedY
    };
}

kernel void computeBezierControlPoints(global read_only const double* restrict points, global write_only double* restrict bezierPoints, float smoothFactor) {
    int i = get_global_id(0);
    bool firstPointInPair = i % 2 == 0;
    int index = floor(i / 2.0);

    const Point a = (const Point) {
        .x = points[(index * 2)],
        .y = points[(index * 2) + 1]
    };
    const Point b = (const Point) {
        .x = points[(index * 2) + 2],
        .y = points[(index * 2) + 3]
    };
    const Point c = (const Point) {
        .x = points[(index * 2) + 4],
        .y = points[(index * 2) + 5]
    };

    const Point bezierPoint = calculateBezierPoint(
        &a,
        &b,
        &c,
        firstPointInPair ? &a : &c,
        smoothFactor,
        firstPointInPair ? 1 : -1
    );

    bezierPoints[(index * 4) + (firstPointInPair ? 0 : 2)] = bezierPoint.x;
    bezierPoints[(index * 4) + (firstPointInPair ? 1 : 3)] = bezierPoint.y;
}